<template>
  <VBtn
    prepend-icon="mdi-download"
    @click="execute"
    :loading="loading"
    variant="elevated"
    color="primary"
  >
    {{ t('export') }}
  </VBtn>
</template>

<script setup lang="ts">
import type { Ranklist } from '@aoi-js/common'
import type { IUserProfile } from '@aoi-js/server'
import ky from 'ky'
import { ref } from 'vue'
import { useI18n } from 'vue-i18n'
import { useToast } from 'vue-toastification'
import * as xlsx from 'xlsx'

import { AsyncQueue } from '@/utils/async'
import { http } from '@/utils/http'

const { t } = useI18n()
const toast = useToast()

const props = defineProps<{
  contestId: string
  ranklistKey: string
}>()
const loading = ref(false)

async function getProfile(_id: string) {
  const endpoint = `user/${_id}/profile`
  const profile = await http.get(endpoint).json<IUserProfile>()
  return profile
}

const bash_header = `
#!/bin/bash
# This script is generated by AOI

if ! command -v jq &> /dev/null; then
  echo "jq is required to run this script"
  exit 1
fi
if ! command -v curl &> /dev/null; then
  echo "curl is required to run this script"
  exit 1
fi

AOI_TOKEN='{{token}}'

function download() {
  local url=$1
  local filename=$2
  local url_resp=$(curl -H "Authorization: Bearer $AOI_TOKEN" -s -X GET "$url/download")
  echo "Response: $url_resp"
  local download_url=$(echo $url_resp | jq -r '.url')
  curl --output $filename -L $download_url
}

`.trimStart()

function writeFileCommand(path: string, content: string) {
  return `
cat <<"EOF" >"${path}"
${content}
EOF
`.trimStart()
}

function downloadFileCommand(path: string, url: string) {
  return `
download "${url}" "${path}"
`.trimStart()
}

function optionalUnzipCommand(path: string, outDir: string) {
  return `
if command -v 7z &> /dev/null; then
  7z x -o"${outDir}" "${path}" || echo "Failed to unzip ${path}"
fi
`.trimStart()
}

const fetchQueue = new AsyncQueue(16)

async function exportRanklist() {
  const toastMsg = t('start-generating')
  const toastId = toast.info(toastMsg, { timeout: false })
  try {
    const endpoint =
      `contest/${props.contestId}/` +
      `ranklist/${encodeURIComponent(props.ranklistKey)}/url/download`
    const { url } = await http.get(endpoint).json<{ url: string }>()
    const { participant, ...rest } = await ky.get(url).json<Ranklist>()
    let script = bash_header.replace('{{token}}', localStorage.getItem('aoi-auth-token') || '')
    script += writeFileCommand('metadata.json', JSON.stringify(rest, null, 2))
    const participantDigits = participant.list.length.toString().length
    toast.update(toastId, { content: `${toastMsg} (0/${participant.list.length})` })
    let processed = 0
    await Promise.all(
      Array.from({ length: participant.list.length }).map((_, i) =>
        fetchQueue
          .enqueue(() => getProfile(participant.list[i].userId))
          .then((profile) => {
            const dirName = `participant_${(i + 1).toString().padStart(participantDigits, '0')}`
            script += `mkdir -p ${dirName}\n`
            const { userId, columns, ...rest } = participant.list[i]
            script += writeFileCommand(
              `${dirName}/metadata.json`,
              JSON.stringify({ ...profile, ...rest }, null, 2)
            )
            for (let j = 0; j < participant.columns.length; j++) {
              const defn = participant.columns[j]
              const data = columns[j]
              if (!data.solutionId) continue
              const solDirName = `${dirName}/problem_${defn.name}`
              script += `mkdir -p ${solDirName}\n`
              script += writeFileCommand(
                `${solDirName}/metadata.json`,
                JSON.stringify(data, null, 2)
              )
              const base = new URL(
                `/api/contest/${props.contestId}/solution/${data.solutionId}/`,
                window.location.origin
              )
              const dataUrl = new URL(`data`, base)
              const detailsUrl = new URL(`details`, base)
              script += downloadFileCommand(`${solDirName}/data.zip`, dataUrl.toString())
              script += downloadFileCommand(`${solDirName}/details.json`, detailsUrl.toString())
              script += optionalUnzipCommand(`${solDirName}/data.zip`, `${solDirName}/files`)
            }
            processed++
            toast.update(toastId, {
              content: `${toastMsg} (${processed}/${participant.list.length})`
            })
          })
      )
    )
    const file = new Blob([script], { type: 'text/plain' })
    const a = document.createElement('a')
    a.href = URL.createObjectURL(file)
    a.download = 'export.sh'
    a.click()
    URL.revokeObjectURL(a.href)
    toast.success(t('successfully-generated'))
  } catch (e) {
    const msg = e as string
    toast.error(t('failed-to-generate') + ': ' + msg)
  }
  toast.dismiss(toastId)
}

async function execute() {
  loading.value = true
  await exportRanklist()
  loading.value = false
}
</script>
<i18n>
en:
  start-generating: Start generating
  successfully-generated: Successfully generated
  failed-to-generate: Failed to generate
  export: Export Ranklist with Files
zh-Hans:
  start-generating: 开始生成
  successfully-generated: 成功生成
  failed-to-generate: 生成失败
  export: 导出排行榜和相关数据文件
</i18n>
